# Chap 1 引论
## 编译阶段  
### 词法分析程序（扫描程序，scanner）：得出token
* token 包括标识符、关键字、运算符和分隔符等。

### 语法分析程序（parser）：生成分析树或语法树
* 定义了程序的结构元素及其关系
* __分析树__ 的内部节点均由其表示的结构名称示出，叶子则表示输入中的记号序列。
* **语法树** 是分析树的压缩形式  

### 语义分析程序（semantic analyzer）：注释语法树
* 负责类型检查。
* 接着，用所有的子表达式的类型来标注语法树，并检查赋值是否使这些类型有意义了。

### 中间代码生成器 ：得出中间代码（intermediate code）
### （独立于机器的）代码优化器
### 代码生成器（Code generator）：目标代码
### 目标代码优化器  

## 编译器中主要的数据结构
1. 记号，token
2. 分析树，syntax tree
3. 符号表，symbol table：记录标识符及其各种属性。  
	当源程序中的一个标识符被词法分析器识别出来时，词法分析器将在符号表中该标识符建立一条记录，而它的属性信息将由后面的各个阶段写入符号表。
	
===
# Chap 2 词法分析 lexical analysis
## 扫描过程
标记通常被定义为枚举类型的逻辑项，包括下列五类：  
1. 关键字（保留字），keyword  
2. 标识符，identifier  
3. 常数，const  
4. 运算符，symbols  
5. 分隔符

##正则表达式 regular expression
### 定义
* 字母表 Σ
* 空串 ε

### 正则表达式的运算
* 选择 "|": x|y
* 联结 “•”: x•y 或 xy
* 闭包“\*”: R\* = ε|R|RR|RRR|RRRR...

### 扩展的正则表达式
* 一次或多次重复 R+ = R|RR|RRR|RRRR...
* 可选的子表达式 R? = R | ε
* 字符范围 [a-d] = a|b|c|d; [acdg]=a|c|d|g
* 不包括 [~a-z]

##有限自动机  Finite Automata
### 确定性有限自动机（DFA）  
##### *定义*  
确定性有限自动机由字母表Σ、状态集合S、转换函数T：S×Σ→S、初始状态s<sub>0</sub>∈S以及接受状态的集合A⊂S组成。………………

### 先行、回溯和非确定性自动机  
![](http://7xt5ki.com1.z0.glb.clouddn.com/16-4-19/41794974.jpg)  

* other带方括号表示了分隔符应该**先行（lookahead）**考虑，即将其返回到输入串中，不能丢掉。
* 这个新的图示还表述了最长子串原理: DFA将一直(在状态i n _ i d中) 匹配字母和数字直到找到一个分隔符。
* 将有穷自动机的定义扩展到包括了对某一特定字符一个状态存在有多个转换的情况，新的有穷自动机称为***非确定性有限自动机（NFA）***
* ε-转换：是无需考虑输入串(且无需消耗任何字符)就有可能发生的转换。 它可看作是一个空串的“匹配”。  
![](http://7xt5ki.com1.z0.glb.clouddn.com/16-4-19/66673047.jpg)

#####非确定性自动机的定义
NFA(nondeterministic finite automaton)M由字母表∑、状态的集合S、转换函数T:S×(∑∪{ε})→ (S)、S的初始状态s<sub>0</sub> ,以及S的接受状态A的集合组成。由M接受 的语言写作L (M),它被定义为字符c<sub>1</sub>c<sub>2</sub>. . . c<sub>n</sub>,其中每一个c<sub>i</sub>都属于∑∪{ε},且存在关系:s<sub>1</sub>在T(s<sub>0</sub>, c<sub>1</sub>) 中、s<sub>2</sub> 在T(s<sub>1</sub> , c<sub>2</sub>) 中、. . .、s<sub>n</sub>在T (s , c<sub>n</sub>) 中,s<sub>n</sub>是A中的元素。  

* NFA并不表示算法,但是却可通过一个在每个非确定性选择中回溯的算法来模拟它？？

###用代码实现有穷自动机
##### A better method
* 用一个变量state来维护当前的状态，并将转换写成一个双层嵌套的case语句。其中外层case语句测试当前的状态,嵌套着的内层case语句测试输入字符及所给状态。

##### 转换表

|状态/输入|字母|数字|其他|接受|
|---|---|---|
|1|2|||不|
|2|2|2|[3]|不|
|3||||是|

给定了恰当的数据结构和表项，就可以用代码实现DFA，这种方式称为**表驱动**

## 从正则表达式到DFA

st=>start: 项目Export   
e=>end: 结束   
op1=>operation: 选择java下的javadoc  
op2=>operation: 选择要导出的工程   
op3=>operation: java doc的配置设置  
st->op1->op2->op3->e  
</srcipt>

===
# Chap 5  自底向上语法分析
## 5.1 概述
* 自底向上分析使用了**显式栈**来完成分析
* 分析栈包括记号和非终结符
### 分析过程
* 分析开始时栈是空的，只有开始符号$
* 分析过程中有两种动作（除“接受（accept）”之外)  
	1. 将终结符从输入的开头移进到栈的顶部  
	1. 假设有BNF选择A -> α，将栈顶部的串α归约（reduce）为**非终结符A**

因此自底向上的分析过程也被称为“移进——归约分析程序”  



﻿