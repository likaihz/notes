#chap 1 数字系统与信息
* 原码、反码、补码
* BCD码（有权码：8421， 84-2-1...）
* ASCII码： ‘0’ ：48， ‘A’：65，‘a’：97
* 格雷码：相邻两个值的编码只有一位不同；

----------------------------------------------------------------------------------
#chap 2 组合逻辑电路
##布尔代数
* 一些定律
交换律：与、或 
结合律：与、或
分配律：X(Y+Z) = XY + XZ,  X+YZ = (X+Y)(X+Z)  --比较特殊
德摩根定律
覆盖律：A(A+B) = A,   A+AB = A (好像其实也就是分配律推出来的）
##对偶式
一个布尔表达式的对偶式可以通过交换与运算和或运算，用1替换0和用0替换1来获得
对偶式与原来的表达式并不一定相等。
* 对偶原则：如果等式两边同时取对偶式，等式依然成立。
> 比如上面的分配律的两个式子就是对偶式。

* 一致律定理
XY + X～Z + YZ = XY + X～Z
即左边第三项是冗余项

##反函数
有一个简单的方法求反函数，就是求该函数的对偶式，并将每一个文字取反。

> Additional Rules
> 替换规则：在一个逻辑等式中，将一个变量全部替换为一个逻辑函数，等式依然成立；
> 香农公式: xf(x, x~, y, ..., z) = x f(1, 0, y, ..., z)

##逻辑函数的化简
略

##标准形式 Standard Forms
###最小项和最大项 Minterms and Maxterms
* 最小项：所有变量以原变量或者反变量的形式出现且出现一次的**乘积项**。
* 最大项：所有变量以原变量或者反变量的形式出现且出现一次的**求和项**。
最小项取反就是对应的最大项

###SOP 和 POS

##卡诺图 Karnaugh Maps
* 注意排列的顺序是按照格雷码的顺序
### 质主蕴涵项
* 蕴涵项 implicant ：如果函数对某一个乘积项的每一个最小项都取值为1，则这个乘积项是函数的一个蕴涵项，反映到卡诺图中就是一个任意大小的正方格；（最大的概念）
* 主蕴涵项 prime implicant：卡诺图中一个最大的方格对应的乘积项是一个主蕴涵项，即如果从蕴涵项移去任何一个变量所得的乘积项都不再是蕴涵项则该蕴涵项是主蕴涵项；
* 质主蕴涵项（又称必要主蕴涵项）：如果函数的某个最小项只包含在一个主蕴涵项中，则该主蕴涵项是质主蕴涵项。

##和之积的优化
对卡诺图中的0进行化简得到F~，再取反。
##无关最小项
在卡诺图中用一个X表示

-----------------------------------------------------------------------------------------------------
# Chap 3 组合逻辑电路的设计
##组合电路 Combinational Circuits
* 定义：在任何时刻，电路的输出都只取决于当前的输入值，那么这样的电路成为组合电路。
###组合电路的分析方法
1. 根据电路写出逻辑函数
2. 列出真值表
3. 事件功能性分析
4. 评价或者改进

## 设计过程
* 功能描述 Specification
* 形式化 Formulation
* 优化 Optimization
* 工艺映射 Technology Mapping
* 验证 Verification
##通用逻辑功能设计
###译码器 Decoder

###编码器 Encoder
优先编码器：不知道是什么鬼，应该也不会考的
###选择——多路复用器 Multiplexer
n位选择输入以及2^n组数据输入。
* 其实也就是个译码器加上若干与门
* 位扩展：选择位向量

##可编程逻辑器件
###只读存储器 ROM
N条输入线：地址输入
M位输出线：数据输出
一共能够存储最多2^N * M位数据。
结构：译码器输出连接M个2^N扇入的或门，编程（一次性）の过程就是或门的输入与译码器的输出是否连接。

###可编程逻辑阵列 PLA
可编程的与门生成乘积项， 可编程的或门将这些乘积项相加

###可编程阵列逻辑 PAL
固定的或门阵列，可编程的与门阵列。


------------------------------------------------------------------
#Chap 4 算数功能模块
##迭代组合电路 Iterative combinational circuits
**略**
##二进制加法器
###半加器 Half-adder：实现两个一位二进制数相加
输入：操作数X, Y
输出：和（S），进位（C）
真值表
----------
| X | Y | C | S |
|---|---|---|---|
|0|0|0|0|
|0|1|0|1|
|1|0|0|1|
|1|1|1|0| 
###全加器 Full-adder：实现三个一位二进制数相加
输入：操作数X，Y，Z
输出：和（S），进位（C）
真值表
------------
| X | Y |Z| C | S |
|---|---|---|
|0|0|0|0|0|
|0|0|1|0|1|
|0|1|0|0|1|
|0|1|1|1|0|
|1|0|0|0|1|
|1|0|1|1|0| 
|1|1|0|1|0| 
|1|1|1|1|1| 
###行波进位加法器 Ripple carry adder

##二进制减法（无符号数）
对于M-N：
用M加上N的补码来实现，如果结果有进位即M不小于N，则丢弃进位，产生的结果正确；如果没有进位即M小于N，则对结果取反并加上一个负号。
* 溢出检测逻辑：最高位的进位和次高位的进位做异或运算，结果为0则没有发生溢出。

-------------------------------------------------------------------------------------------------------------------------------------------------
#Chap 5 时序电路 Sequential Logic
##锁存器和触发器
特征方程：
D触发器：Q(t+1) = D(t)
SR触发器：Q(t+1) = S(t) + R~(t)Q(t)
##时序电路分析
* 输入方程
* 状态表：当前状态，输入，下一状态，输出
* 输出依赖于当前状态和输入的称为Mealay电路， 只依赖于当前状态的称为Moore电路。
###状态图
坑的了！！

